# Блочная (корзинная) сортировка
### Определение алгоритма
Блочная сортировка (bucket sort) — это алгоритм, который распределяет элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их
значений. После этого каждая корзина сортируется отдельно (либо тем же методом рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины
объединяются обратно в один массив.

### Объяснение работы алгоритма:
Алгоритм проходит по массиву и распределяет элементы по корзинам в зависимости от их значений (for num in arr:).

На каждом шаге он вычисляет индекс корзины для текущего элемента с помощью функции распределения (index = int(num * num_buckets / (max_val + 1))).

После распределения всех элементов по корзинам, каждая корзина сортируется индивидуально (bucket.sort()).

После сортировки всех корзин они объединяются в результирующий массив в порядке возрастания индексов корзин.  result.extend(bucket)

Процесс повторяется, пока все элементы не будут распределены по корзинам и отсортированы.  for bucket in buckets:

### Временная сложность
Временная сложность — O(n + k).

### Почему такая сложность:
Наличие этапа распределения по корзинам (O(n)) и этапа сортировки корзин (в среднем O(k × (n/k)log(n/k))) приводит к общей сложности O(n + k). В лучшем случае, при равномерном распределении, сложность составляет O(n), а в худшем случае, когда все элементы попадают в одну корзину, сложность достигает O(n²).

# Блинная сортировка
### Определение алгоритма
— это метод, основанный на операции переворота (reversal) части массива. В отличие от большинства алгоритмов, которые обменивают соседние элементы или выбирают опорные точки, здесь единственная разрешённая операция — переворот префикса массива до выбранного индекса.

### Объяснение работы алгоритма:
Алгоритм проходит по массиву от конца к началу (for curr_size in range(n, 1, -1)).

На каждом шаге он находит максимальный элемент в неотсортированной части массива (max_index = arr.index(max(arr[:curr_size]))).

Если максимальный элемент не находится на своем месте, алгоритм выполняет два переворота: сначала переворачивает часть массива до позиции максимального элемента, чтобы он оказался первым (flip(arr, max_index + 1)), затем переворачивает всю неотсортированную часть, чтобы максимальный элемент оказался в конце (flip(arr, curr_size)).

Процесс повторяется, пока весь массив не будет отсортирован. for curr_size in range(n, 1, -1):

### Временная сложность
Временная сложность — O(n²).

### Почему такая сложность:
Наличие внешнего цикла (n раз) и внутренних операций поиска максимума (O(n)) и переворота (O(n)) приводит к квадратичной сложности O(n²). Каждый элемент требует до двух переворотов, что в худшем случае дает 2n операций переворота.

# Сортировка бусинами (гравитационная)
### Определение алгоритма
Сортировка бусинами (bead sort), также известная как гравитационная сортировка, моделирует естественное поведение бусин, падающих вниз под действием гравитации. Этот алгоритм разработали Джошуа Аруланандхам, Кристиан Калюд и Майкл Диннин в 2002 году.

### Объяснение работы алгоритма:
Алгоритм создает матрицу бусин, где каждая строка представляет значение элемента (beads = [[0] * len(arr) for _ in range(max_val)]).

Каждый элемент массива представляется в виде горизонтального ряда бусин, количество которых соответствует его значению (for i, num in enumerate(arr): for j in range(num): beads[j][i] = 1).

Под действием "гравитации" бусины падают вниз, для чего подсчитывается количество бусин в каждом ряду и они перераспределяются в нижние позиции (bead_count = sum(beads[i]) и последующий цикл перераспределения).

После оседания бусин строки считываются сверху вниз, получая отсортированный массив (for i in range(len(arr)): for j in range(max_val): result[i] += beads[j][i]).

Процесс повторяется, пока все бусины не осядут под действием гравитации. for i in range(max_val):

### Временная сложность
Временная сложность — O(n).

### Почему такая сложность:
Теоретическая сложность составляет O(n), так как алгоритм выполняет фиксированное количество операций для каждого элемента, однако практическая реализация зависит от максимального значения в массиве и может быть выше из-за ограничений на диапазон значений.

# Поиск скачками (Jump Search)
### Определение алгоритма
Поиск скачками — это оптимизация линейного поиска для отсортированных массивов, при
которой алгоритм «прыгает» через определённое число элементов (обычно через n), чтобы
быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного
диапазона.

### Объяснение работы алгоритма:
Алгоритм определяет размер прыжка как квадратный корень из длины массива (step = int(math.sqrt(n))).

Алгоритм прыгает вперед на step элементов, пока не найдет элемент, больше или равный искомому (while arr[min(step, n) - 1] < target:).

Когда найден блок, содержащий искомый элемент, выполняется линейный поиск в предыдущем блоке (for i in range(prev, min(step, n)):).

Процесс повторяется, пока не будет найден искомый элемент или не будет пройден весь массив. if prev >= n:

### Временная сложность
Временная сложность — O(√n).

### Почему такая сложность:
Наличие прыжков размером √n и последующего линейного поиска в блоке размером √n приводит к общей сложности O(√n). В худшем случае требуется √n прыжков и √n сравнений в блоке, что дает 2√n операций.

# Экспоненциальный поиск (Exponential Search)
### Определение алгоритма
Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя быстро определить диапазон, в котором может находиться искомое значение, а затем применяет двоичный поиск в этом диапазоне.

### Объяснение работы алгоритма:
Алгоритм сначала проверяет первый элемент массива (if arr[0] == target:).

Если элемент не найден в начале, алгоритм экспоненциально увеличивает диапазон поиска, удваивая границу на каждом шаге (i = 1 while i < n and arr[i] <= target: i *= 2).

Когда найден диапазон, где элемент больше или равен целевому, алгоритм выполняет бинарный поиск в этом диапазоне (return binary_search(arr, i // 2, min(i, n - 1), target)).

Бинарный поиск выполняется между предыдущей границей (i//2) и текущей границей (i), ограниченной размером массива.

Процесс повторяется, пока не будет найден искомый элемент или не будет определено его отсутствие. while left <= right:

### Временная сложность
Временная сложность — O(log n).

### Почему такая сложность:
Экспоненциальное увеличение диапазона занимает O(log n) шагов, и последующий бинарный поиск также выполняется за O(log n), что дает общую сложность O(log n). Алгоритм эффективен для больших отсортированных массивов.

# Тернарный поиск (Ternary Search)
### Определение алгоритма
Тернарный поиск — это метод деления диапазона поиска на три части (в отличие от двух в
бинарном) и рекурсивного сужения диапазона до тех пор, пока не будет найден элемент или
экстремум функции (в зависимости от задачи).
### Объяснение работы алгоритма:
Алгоритм делит диапазон индексов на три равные части (mid1 = left + (right - left) // 3 и mid2 = right - (right - left) // 3).

Сравнивается искомый элемент с элементами на двух разделительных границах (if arr[mid1] == target: и if arr[mid2] == target:).

Если совпадение не найдено, алгоритм определяет в какой из трех частей продолжать поиск: если элемент меньше левой границы - в первой трети (return recursive_search(left, mid1 - 1)), если больше правой границы - в последней трети (return recursive_search(mid2 + 1, right)), иначе - в средней трети (return recursive_search(mid1 + 1, mid2 - 1)).

Процесс повторяется рекурсивно (def recursive_search(left, right):), пока не будет найден искомый элемент или диапазон поиска не станет пустым (if left > right: return -1).

### Временная сложность
Временная сложность — O(log₃n).

### Почему такая сложность:
На каждом шаге алгоритм делит диапазон поиска на три части (mid1 = left + (right - left) // 3 и mid2 = right - (right - left) // 3) и отбрасывает две трети, что приводит к логарифмической сложности с основанием 3. Каждый рекурсивный вызов (recursive_search()) уменьшает проблему в 3 раза.



