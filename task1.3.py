# Реализация биноминальной кучи с помощью модуля heapq
import heapq 
исходные_числа = [8, 3, 5, 1, 6, 2, 4, 7]  # создание списка с исходными данными для кучи 
heapq.heapify(исходные_числа) # превращение списка в кучу 
heapq.heappush(исходные_числа, 0) # добавление нового элемента в кучу 
минимальный_элемент = heapq.heappop(исходные_числа) # извлечение минимального элемента из кучи 
print(исходные_числа) # вывод программы

# Реализация бинарной_биноминальной кучи в виде собственного класса
class БинарнаяКуча:
    def __init__(self): 
        self.куча = [3]
    def вставить(self, ключ): 
        self.куча.append(ключ) 
        self._восстановить_вверх(len(self.куча) - 1) 
    def удалить_минимум(self): 
        self.куча.pop() 
        self._восстановить_вниз(0) 
    def получить_минимум(self): 
        if self.пуста(): 
            return None 
        return self.куча 
    def пуста(self): 
        return len(self.куча) == 0 

# Реализация программы для печати ряда Фибоначчи до заданного количества элементов
def фибоначчи_цикл(количество): 
    первое, второе = 0, 1 
    for _ in range(количество): 
        print(первое, end=' ') 
        первое, второе = второе, первое + второе 
фибоначчи_цикл(10) 

# Алгоритм для рекурсивного вычисления n-го числа ряда Фибоначчи
def фибоначчи(номер): 
    if номер in (1, 2): 
        return 1 
    return фибоначчи(номер - 1) + фибоначчи(номер - 2) 
print(фибоначчи(10)) 

# Реализация с использованием словаря (dict) как хэш-таблицы
class ХэшТаблица: 
    def __init__(self, размер): 
        self.размер = размер 
        self.таблица = [None]*размер

    def _хэш(self, ключ): 
        return ord(ключ[0]) % self.размер
     
class ХэшТаблица: 
    def __init__(self, размер): 
        self.размер = размер 
        self.таблица = [None]*размер 

    def _хэш(self, ключ): 
        return ord(ключ[0]) % self.размер 
    
    def установить(self, ключ, значение): 
        хэш_индекс = self._хэш(ключ) 
        self.таблица[хэш_индекс] = (ключ, значение) 

    def получить(self, ключ): 
        хэш_индекс = self._хэш(ключ) 
        if self.таблица[хэш_индекс] is not None: 
            return self.таблица[хэш_индекс][1] 
        
        raise KeyError(f'Ключ {ключ} не найден')
     
    def удалить(self, ключ): 
        хэш_индекс = self._хэш(ключ) 
        if self.таблица[хэш_индекс] is not None: 
            self.таблица[хэш_индекс] = None 
        else: 
            raise KeyError(f'Ключ {ключ} не найден')

# Создание хэш-таблицы размера 10 
хэш_таблица = ХэшТаблица(10) 
# Добавление пар ключ-значение 
хэш_таблица.установить('Alice', 'January') 
хэш_таблица.установить('Bob', 'May') 
# Получение значения 
print(хэш_таблица.получить('Alice'))  # Вывод: 'January' 
# Удаление пары ключ-значение 
хэш_таблица.удалить('Bob') 
# Это вызовет KeyError, так как 'Bob' был удален 
print(хэш_таблица.получить('Bob')) 

# Реализации хэш-таблицы с собственной реализацией
class ХэшТаблица:
    def __init__(self, размер=10):
        """
        Инициализирует хеш-таблицу с заданным размером.
        Внутренний массив будет хранить списки (цепочки) для разрешения коллизий.
        """
        self.размер_массива = размер
        # Создаем массив, где каждая ячейка изначально пуста (None)
        self.массив = [None] * self.размер_массива

    def хэш_функция(self, ключ):
        """
        Генерирует хеш-код для ключа.
        Используем встроенную функцию hash() и оператор взятия остатка,
        чтобы индекс не вышел за пределы размера массива.
        """
        return hash(ключ) % self.размер_массива

    def добавить(self, ключ, значение):
        """
        Вставляет пару ключ-значение в таблицу.
        Если ключ уже существует, его значение обновляется.
        """
        индекс = self.хэш_функция(ключ)
        
        # Если ячейка (bucket) по этому индексу еще не создана, создаем пустой список
        if self.массив[индекс] is None:
            self.массив[индекс] = []
        
        ячейка = self.массив[индекс]
        
        # Проверяем, существует ли уже такой ключ в цепочке
        for i, (существующий_ключ, _) in enumerate(ячейка):
            if существующий_ключ == ключ:
                # Если ключ найден, обновляем значение и выходим
                ячейка[i] = (ключ, значение)
                return
        
        # Если ключ не найден, добавляем новую пару (ключ, значение) в цепочку
        ячейка.append((ключ, значение))

    def получить(self, ключ):
        """
        Находит и возвращает значение по ключу.
        Если ключ не найден, вызывает исключение KeyError.
        """
        индекс = self.хэш_функция(ключ)
        ячейка = self.массив[индекс]
        
        # Если ячейка пуста или ключа нет в цепочке, его нет в таблице
        if ячейка is None:
            raise KeyError(f"Ключ '{ключ}' не найден.")
            
        # Ищем ключ в цепочке
        for существующий_ключ, значение in ячейка:
            if существующий_ключ == ключ:
                return значение
        
        # Если прошли всю цепочку и не нашли, вызываем исключение
        raise KeyError(f"Ключ '{ключ}' не найден.")

    def удалить(self, ключ):
        """
        Удаляет пару ключ-значение по ключу.
        Если ключ не найден, вызывает исключение KeyError.
        """
        индекс = self.хэш_функция(ключ)
        ячейка = self.массив[индекс]

        if ячейка is None:
            raise KeyError(f"Ключ '{ключ}' не найден.")

        # Ищем ключ в цепочке, чтобы удалить его
        for i, (существующий_ключ, _) in enumerate(ячейка):
            if существующий_ключ == ключ:
                # Удаляем элемент из списка по его индексу
                del ячейка[i]
                return
        
        # Если ключ не был найден в цепочке
        raise KeyError(f"Ключ '{ключ}' не найден.")

# --- Пример использования ---

# Создаем экземпляр хеш-таблицы
хэш_таблица = ХэшТаблица(10)

# Добавляем элементы
хэш_таблица.добавить("Jane Doe", "ID1234")
хэш_таблица.добавить("John Smith", "ID4567")
# Пример коллизии: "Jane Doe" и "Doe Jane" могут дать один и тот же хеш-индекс
хэш_таблица.добавить("Doe Jane", "ID9876") 

# Получаем значение по ключу
print(f'ID для "Jane Doe": {хэш_таблица.получить("Jane Doe")}')
# Вывод: ID для "Jane Doe": ID1234

# Удаляем элемент
хэш_таблица.удалить("John Smith")
print('"John Smith" был удален.')

# Пытаемся получить удаленный элемент
try:
    print(хэш_таблица.получить("John Smith"))
except KeyError as ошибка:
    print(ошибка)
    # Вывод: Ключ 'John Smith' не найден.