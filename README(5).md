### Определение
Алгоритм сортировки выбором (Selection Sort) — это алгоритм, который на каждом шаге находит минимальный элемент в неотсортированной части массива и меняет его местами с первым элементом этой части.

# Объяснение работы алгоритма:
Алгоритм проходит по массиву от начала до предпоследнего элемента (for (int i = 0; i < n - 1; i++)).

На каждом шаге он ищет минимальный элемент в оставшейся неотсортированной части массива (for (int j = i + 1; j < n; j++)).

После нахождения минимального элемента (minIndex) он меняет его местами с текущим элементом (arr[i]), если это необходимо.

После каждого прохода выводится текущее состояние массива для наглядности.

Процесс повторяется, пока весь массив не будет отсортирован.
# Временная сложность
Временная сложность — O(n²).

Почему: наличие внешнего цикла (n-1 раз) и внутреннего цикла (в среднем n/2 раз) приводит к квадратичной сложности.


# Результат выполнения программы:
Исходный массив: 64 25 12 22 11 

После итерации 1: 11 25 12 22 64 

После итерации 2: 11 12 25 22 64 

После итерации 3: 11 12 22 25 64

После итерации 4: 11 12 22 25 64 

Отсортированный массив: 11 12 22 25 64 
# Определение
Алгоритм оптимизированной пузырьковой сортировки (Optimized Bubble Sort) — это улучшенная версия алгоритма пузырьковой сортировки, которая прекращает работу, если за полный проход по массиву не было выполнено ни одного обмена элементов.

# Объяснение работы алгоритма:

Алгоритм проходит по массиву несколько раз, сравнивая соседние элементы (for (int j = 0; j < n - i - 1; j++)).

Если текущий элемент больше следующего (arr[j] > arr[j + 1]), они меняются местами.

Вводится флаг swapped, который отслеживает, были ли обмены во внутреннем цикле.

После каждого полного прохода по массиву проверяется значение флага swapped. Если обменов не было (!swapped), это означает, что массив уже отсортирован, и алгоритм завершает работу досрочно.

Внешний цикл выполняется максимум n-1 раз, но может завершиться раньше благодаря оптимизации.

Ключевые особенности оптимизации:

С каждым проходом наибольшие "всплывают" в конец, поэтому внутренний цикл с каждым разом проверяет на один элемент меньше (n - i - 1).

Флаг swapped позволяет избежать лишних проходов, когда массив уже отсортирован.

# Временная сложность

Худший случай: O(n²) — когда массив отсортирован в обратном порядке

Лучший случай: O(n) — когда массив уже отсортирован (благодаря оптимизации)

Средний случай: O(n²)

# Результат выполнения программы:

Исходный массив: 5 1 4 2 8

Отсортированный массив: 1 2 4 5 8 

Процесс сортировки (пошагово):

5 и 1 → обмен: 1 5 4 2 8

5 и 4 → обмен: 1 4 5 2 8

5 и 2 → обмен: 1 4 2 5 8

5 и 8 → без обмена

Следующий проход: 4 и 2 → обмен: 1 2 4 5 8

Далее обменов нет → завершение
task(5.3).cpp
CPP 1.29KB
этот тоже
Определение
Алгоритм сортировки вставками (Insertion Sort) — это алгоритм, который на каждом шаге берёт один элемент из неотсортированной части и вставляет его в правильную позицию в отсортированной части массива, сдвигая элементы при необходимости.

Объяснение работы алгоритма:

Алгоритм начинает со второго элемента (i = 1) и рассматривает его как "ключевой" элемент (key).

Для каждого ключевого элемента выполняется сравнение с элементами в отсортированной части (слева от текущей позиции).

Пока не найден элемент меньший или равный ключу, элементы сдвигаются вправо (arr[j + 1] = arr[j]).

Когда найдена правильная позиция, ключевой элемент вставляется в массив (arr[j + 1] = key).

Процесс повторяется для всех элементов массива, постепенно расширяя отсортированную часть.

Пошаговый процесс для примера {4, 3, 2, 10, 12, 1, 5, 6}:

text
Шаг 1: key = 3
До вставки: 4 3 
После вставки: 3 4 

Шаг 2: key = 2
До вставки: 3 4 2 
После вставки: 2 3 4 

Шаг 3: key = 10
До вставки: 2 3 4 10 
После вставки: 2 3 4 10 

Шаг 4: key = 12
До вставки: 2 3 4 10 12 
После вставки: 2 3 4 10 12 

Шаг 5: key = 1
До вставки: 2 3 4 10 12 1 
После вставки: 1 2 3 4 10 12 

Шаг 6: key = 5
До вставки: 1 2 3 4 10 12 5 
После вставки: 1 2 3 4 5 10 12 

Шаг 7: key = 6
До вставки: 1 2 3 4 5 10 12 6 
После вставки: 1 2 3 4 5 6 10 12 
Временная сложность

Худший случай: O(n²) — когда массив отсортирован в обратном порядке

Лучший случай: O(n) — когда массив уже отсортирован

Средний случай: O(n²)

Преимущества:

Эффективен для небольших массивов

Стабильная сортировка

Адаптивный — хорошо работает с частично отсортированными массивами

Работает "на месте" без дополнительной памяти

Результат выполнения программы:

Исходный массив: 4 3 2 10 12 1 5 6 

Финальный отсортированный массив: 1 2 3 4 5 6 10 12 
