# Определение
# Алгоритм сортировки выбором (Selection Sort)
— это алгоритм, который на каждом шаге находит минимальный элемент в неотсортированной части массива и меняет его местами с первым элементом этой части.

### Объяснение работы алгоритма:
Алгоритм проходит по массиву от начала до предпоследнего элемента (for (int i = 0; i < n - 1; i++)).

На каждом шаге он ищет минимальный элемент в оставшейся неотсортированной части массива (for (int j = i + 1; j < n; j++)).

После нахождения минимального элемента (minIndex) он меняет его местами с текущим элементом (arr[i]), если это необходимо.

После каждого прохода выводится текущее состояние массива для наглядности.

Процесс повторяется, пока весь массив не будет отсортирован.
### Временная сложность
Временная сложность — O(n²).

Почему: наличие внешнего цикла (n-1 раз) и внутреннего цикла (в среднем n/2 раз) приводит к квадратичной сложности.


# Результат выполнения программы:
Исходный массив: 64 25 12 22 11 

После итерации 1: 11 25 12 22 64 

После итерации 2: 11 12 25 22 64 

После итерации 3: 11 12 22 25 64

После итерации 4: 11 12 22 25 64 

Отсортированный массив: 11 12 22 25 64 

# Определение
# Алгоритм оптимизированной пузырьковой сортировки (Optimized Bubble Sort) 
— это улучшенная версия алгоритма пузырьковой сортировки, которая прекращает работу, если за полный проход по массиву не было выполнено ни одного обмена элементов.

### Объяснение работы алгоритма:

Алгоритм проходит по массиву несколько раз, сравнивая соседние элементы (for (int j = 0; j < n - i - 1; j++)).

Если текущий элемент больше следующего (arr[j] > arr[j + 1]), они меняются местами.

Вводится флаг swapped, который отслеживает, были ли обмены во внутреннем цикле.

После каждого полного прохода по массиву проверяется значение флага swapped. Если обменов не было (!swapped), это означает, что массив уже отсортирован, и алгоритм завершает работу досрочно.

Внешний цикл выполняется максимум n-1 раз, но может завершиться раньше благодаря оптимизации.

Ключевые особенности оптимизации:

С каждым проходом наибольшие "всплывают" в конец, поэтому внутренний цикл с каждым разом проверяет на один элемент меньше (n - i - 1).

Флаг swapped позволяет избежать лишних проходов, когда массив уже отсортирован.

### Временная сложность

 O(n²)

Почему: Временная сложность O(n²) возникает из-за вложенных циклов. Даже с оптимизацией, в худшем случае (массив в обратном порядке) алгоритм делает ~n²/2 сравнений.


### Результат выполнения программы:

Исходный массив: 5 1 4 2 8

Отсортированный массив: 1 2 4 5 8 

Процесс сортировки (пошагово):

5 и 1 → обмен: 1 5 4 2 8

5 и 4 → обмен: 1 4 5 2 8

5 и 2 → обмен: 1 4 2 5 8

5 и 8 → без обмена

Следующий проход: 4 и 2 → обмен: 1 2 4 5 8

Далее обменов нет → завершение

# Определение
# Алгоритм сортировки вставками (Insertion Sort)
— это алгоритм, который на каждом шаге берёт один элемент из неотсортированной части и вставляет его в правильную позицию в отсортированной части массива, сдвигая элементы при необходимости.

### Объяснение работы алгоритма:

Алгоритм начинает со второго элемента (i = 1) и рассматривает его как "ключевой" элемент (key).

Для каждого ключевого элемента выполняется сравнение с элементами в отсортированной части (слева от текущей позиции).

Пока не найден элемент меньший или равный ключу, элементы сдвигаются вправо (arr[j + 1] = arr[j]).

Когда найдена правильная позиция, ключевой элемент вставляется в массив (arr[j + 1] = key).

Процесс повторяется для всех элементов массива, постепенно расширяя отсортированную часть.

Пошаговый процесс для примера {4, 3, 2, 10, 12, 1, 5, 6}:

Шаг 1: key = 3
До вставки: 4 3 
После вставки: 3 4 

Шаг 2: key = 2
До вставки: 3 4 2 
После вставки: 2 3 4 

Шаг 3: key = 10
До вставки: 2 3 4 10 
После вставки: 2 3 4 10 

Шаг 4: key = 12
До вставки: 2 3 4 10 12 
После вставки: 2 3 4 10 12 

Шаг 5: key = 1
До вставки: 2 3 4 10 12 1 
После вставки: 1 2 3 4 10 12 

Шаг 6: key = 5
До вставки: 1 2 3 4 10 12 5 
После вставки: 1 2 3 4 5 10 12 

Шаг 7: key = 6
До вставки: 1 2 3 4 5 10 12 6 
После вставки: 1 2 3 4 5 6 10 12 
### Временная сложность

O(n²)

Почему: Сложность O(n²) возникает из-за вложенного цикла, который в худшем случае и среднем случае для каждого из n элементов должен пройти и сравнить его с значительной частью уже отсортированного массива.

### Результат выполнения программы:

Исходный массив: 4 3 2 10 12 1 5 6 

Финальный отсортированный массив: 1 2 3 4 5 6 10 12 

# Определение
# Алгоритм сортировки слиянием (Merge Sort)
— это алгоритм, который рекурсивно разделяет массив на две половины до тех пор, пока каждая часть не будет содержать 0 или 1 элемент, а затем сливает эти части в отсортированном порядке.

### Объяснение работы алгоритма:
Алгоритм работает по принципу "разделяй и властвуй". Он делит массив пополам (рекурсивно в функции mergeSort), пока не достигнет базового случая (массив из 0 или 1 элемента).

Затем алгоритм сливает отсортированные половины обратно в функцию merge, создавая временные массивы для левой и правой частей, сравнивая элементы и объединяя их в правильном порядке.

После каждого слияния выводится текущее состояние обработанной части массива для наглядности.

Процесс повторяется рекурсивно, пока весь массив не будет отсортирован.

### Временная сложность
Временная сложность — O(n log n).

Почему: массив делится пополам на каждом уровне рекурсии (log n уровней), а на каждом уровне выполняется слияние за O(n) операций.

### Результат выполнения программы для массива {38, 27, 43, 3, 9, 82, 10}:

Исходный массив: 38 27 43 3 9 82 10 

Сортировка [0-6]
  Сортировка [0-3]
    Сортировка [0-1]
      Сортировка [0-0]
      Сортировка [1-1]
      Слияние [0-0] и [1-1]
      Результат: 27 38
    Сортировка [2-3]
      Сортировка [2-2]
      Сортировка [3-3]
      Слияние [2-2] и [3-3]
      Результат: 3 43
    Слияние [0-1] и [2-3]
    Результат: 3 27 38 43
  Сортировка [4-6]
    Сортировка [4-5]
      Сортировка [4-4]
      Сортировка [5-5]
      Слияние [4-4] и [5-5]
      Результат: 9 82
    Сортировка [6-6]
   Слияние [4-5] и [6-6]
  Результат: 9 10 82
 Слияние [0-3] и [4-6]
 Результат: 3 9 10 27 38 43 82

Финальный отсортированный массив: 3 9 10 27 38 43 82 
# Определение
# Алгоритм сортировки Шелла (Shell Sort) 
— это алгоритм, который на каждом шаге сравнивает элементы, расположенные на определенном расстоянии друг от друга, и постепенно уменьшает это расстояние до 1.

### Объяснение работы алгоритма:
Алгоритм начинает с большого шага (gap = n // 2) и последовательно уменьшает его. На каждом шаге выполняется сортировка вставками для элементов, отстоящих друг от друга на расстоянии gap.

Алгоритм проходит по массиву с начальным шагом n//2 (while gap > 0).

Для каждого шага он выполняет сортировку вставками для элементов, находящихся на расстоянии gap друг от друга (for i in range(gap, n)).

Для каждого элемента temp = arr[i] он сдвигает элементы влево, пока не найдет правильную позицию в своем подмассиве (while j >= gap and arr[j - gap] > temp).

После обработки каждого шага gap уменьшается вдвое (gap //= 2).

Процесс повторяется, пока шаг не станет равным 1 и массив не будет полностью отсортирован.

### Временная сложность
Временная сложность —O(n log²n) 

Почему: наличие внешнего цикла по шагам (log n раз) и внутренних циклов сортировки вставками с разными шагами.

### Результат выполнения программы:
Исходный массив: [64, 34, 25, 12, 22, 11, 90, 5]

При gap = 4: сравниваются [64,22], [34,11], [25,90], [12,5] → [22, 11, 25, 5, 64, 34, 90, 12]

При gap = 2: сравниваются элементы с шагом 2 → [11, 5, 22, 12, 25, 34, 64, 90]

При gap = 1: выполняется полная сортировка вставками → [5, 11, 12, 22, 25, 34, 64, 90]

Отсортированный массив: [5, 11, 12, 22, 25, 34, 64, 90]
# Определение
# Алгоритм быстрой сортировки (Quick Sort)
— это алгоритм, который использует стратегию "разделяй и властвуй", выбирая опорный элемент и разделяя массив на три части: элементы меньше опорного, равные опорному и больше опорного.

### Объяснение работы алгоритма:
Алгоритм рекурсивно разделяет массив вокруг опорного элемента. На каждом шаге он выбирает опорный элемент (pivot = arr[len(arr)//2]), затем создает три подмассива:

left = [x for x in arr if x < pivot] — все элементы, меньшие опорного

middle = [x for x in arr if x == pivot] — все элементы, равные опорному

right = [x for x in arr if x > pivot] — все элементы, большие опорного

После разделения алгоритм рекурсивно применяется к левому и правому подмассивам (quicksort(left) + middle + quicksort(right)).

Базовый случай рекурсии: когда массив содержит 0 или 1 элемент (if len(arr) <= 1), он уже считается отсортированным.

Процесс повторяется рекурсивно, пока все подмассивы не будут отсортированы.

### Временная сложность
Временная сложность — O(n log n)

Почему:массив делится пополам на каждом уровне рекурсии (log n уровней), на каждом уровне выполняется O(n) операций. В худшем случае (неудачный выбор опорного элемента) деление неравномерное.

### Результат выполнения программы для массива [3, 6, 8, 10, 1, 2, 1]:

Рекурсивный вызов 1: pivot = 8
left = [3, 6, 1, 2, 1], middle = [8], right = [10]

Рекурсивный вызов 2 (left): pivot = 1
left = [], middle = [1, 1], right = [3, 6, 2]

Рекурсивный вызов 3 (right): pivot = 3  
left = [2], middle = [3], right = [6]

Объединение: [] + [1, 1] + [2] + [3] + [6] + [8] + [10]

Отсортированный массив: [1, 1, 2, 3, 6, 8, 10]
# Определение
# Алгоритм пирамидальной сортировки (Heap Sort)
— это алгоритм, который использует структуру данных "двоичная куча" (binary heap) для сортировки элементов.

### Объяснение работы алгоритма:
Алгоритм состоит из двух основных этапов: построения max-heap и последовательного извлечения элементов.

Первый этап: построение max-heap из исходного массива (for (int i = n / 2 - 1; i >= 0; i--) heapify(arr, n, i)). На этом этапе массив преобразуется в двоичную кучу, где каждый родительский элемент больше или равен своим потомкам.

Второй этап: последовательное извлечение максимального элемента из кучи (for (int i = n - 1; i > 0; i--)). На каждом шаге максимальный элемент (находящийся в корне) перемещается в конец массива, и свойство кучи восстанавливается для оставшихся элементов.

Функция heapify восстанавливает свойство кучи для поддерева с корнем в узле i, рекурсивно проверяя и исправляя нарушение свойства max-heap.

Временная сложность
Временная сложность — O(n log n).

Почему: построение кучи занимает O(n) времени, а каждый из n вызовов heapify занимает O(log n) времени.

### Результат выполнения программы для массива {12, 11, 13, 5, 6, 7}:

Исходный массив: 12 11 13 5 6 7 

Построение max-heap:
- Исходное дерево: [12, 11, 13, 5, 6, 7]
  
- После heapify: [13, 11, 12, 5, 6, 7]

Процесс сортировки:
Шаг 1: swap(13, 7) → [7, 11, 12, 5, 6, 13], heapify → [12, 11, 7, 5, 6, 13]

Шаг 2: swap(12, 6) → [6, 11, 7, 5, 12, 13], heapify → [11, 6, 7, 5, 12, 13]

Шаг 3: swap(11, 5) → [5, 6, 7, 11, 12, 13], heapify → [7, 6, 5, 11, 12, 13]

Шаг 4: swap(7, 5) → [5, 6, 7, 11, 12, 13], heapify → [6, 5, 7, 11, 12, 13]

Шаг 5: swap(6, 5) → [5, 6, 7, 11, 12, 13]

Отсортированный массив: 5 6 7 11 12 13 
# Определение
# Алгоритм последовательного поиска (Sequential Search)
— это алгоритм, который последовательно проверяет каждый элемент массива до тех пор, пока не найдет искомый элемент или не проверит все элементы.

### Объяснение работы алгоритма:
Алгоритм проходит по массиву от начала до конца (for index, value in enumerate(arr)), проверяя каждый элемент на соответствие целевому значению.

На каждом шаге он сравнивает текущий элемент с искомым значением (if value == target).

Если элемент найден, алгоритм немедленно возвращает его индекс (return index).

Если алгоритм доходит до конца массива и не находит искомый элемент, он возвращает None (return None).

Процесс прекращается либо при нахождении элемента, либо при полном прохождении массива.

### Временная сложность
Временная сложность — O(n).

Почему: в худшем случае алгоритму необходимо проверить все n элементов массива.

### Результат выполнения программы для массива [10, 20, 30, 40, 50, 60] и искомого значения 30:

Проверка элемента 10 на индексе 0: не совпадает

Проверка элемента 20 на индексе 1: не совпадает

Проверка элемента 30 на индексе 2: СОВПАДАЕТ

Значение 30 найдено на индексе 2
# Определение
# Алгоритм бинарного поиска (Binary Search) 
— это алгоритм, который находит позицию целевого элемента в отсортированном массиве путем последовательного деления диапазона поиска пополам.

### Объяснение работы алгоритма:
Алгоритм работает только с отсортированным массивом. Он определяет начальный диапазон поиска (low = 0, high = len(arr) - 1) и продолжает поиск, пока диапазон не исчерпается (while low <= high).

На каждом шаге алгоритм находит средний элемент диапазона (mid = (low + high) // 2) и сравнивает его с целевым значением.

Если средний элемент равен целевому (arr[mid] == target), алгоритм возвращает его индекс (return mid).

Если средний элемент меньше целевого (arr[mid] < target), алгоритм сужает диапазон поиска до правой половины (low = mid + 1).

Если средний элемент больше целевого, алгоритм сужает диапазон поиска до левой половины (high = mid - 1).

Процесс повторяется до нахождения элемента или исчерпания диапазона поиска.

### Временная сложность
Временная сложность — O(log n).

Почему: на каждом шаге алгоритм уменьшает диапазон поиска вдвое, что приводит к логарифмическому количеству итераций.

### Результат выполнения программы для массива [1, 3, 5, 7, 9, 11, 13, 15] и искомого значения 7:

Итерация 1: low=0, high=7, mid=3, arr[3]=7 → СОВПАДАЕТ

Элемент 7 найден на позиции 3.
# Определение
#Алгоритм интерполяционного поиска (Interpolation Search) 
— это алгоритм, который находит позицию целевого элемента в отсортированном массиве путем вычисления вероятного положения элемента на основе его значения.

### Объяснение работы алгоритма:
Алгоритм работает только с отсортированным массивом. Он определяет начальный диапазон поиска (low = 0, high = arr.size() - 1) и продолжает поиск, пока диапазон не исчерпается и целевое значение находится в пределах массива (while (low <= high && target >= arr[low] && target <= arr[high])).

На каждом шаге алгоритм вычисляет вероятную позицию элемента с помощью интерполяционной формулы: pos = low + ((target - arr[low]) * (high - low)) / (arr[high] - arr[low]).

Если элемент в вычисленной позиции равен целевому (arr[pos] == target), алгоритм возвращает его индекс (return pos).

Если элемент в вычисленной позиции меньше целевого (arr[pos] < target), алгоритм сужает диапазон поиска до правой части (low = pos + 1).

Если элемент в вычисленной позиции больше целевого, алгоритм сужает диапазон поиска до левой части (high = pos - 1).

Процесс повторяется до нахождения элемента или исчерпания диапазона поиска.

### Временная сложность
Временная сложность — O(log log n)

Почему: алгоритм быстро сужает диапазон поиска за счет интерполяции, но в худшем случае (неравномерное распределение) может деградировать до линейного поиска.

### Результат выполнения программы для массива {10, 12, 13, 16, 18, 19, 20, 21, 22, 23, 24, 33, 35, 42, 47} и искомого значения 18:
Массив: 10 12 13 16 18 19 20 21 22 23 24 33 35 42 47 
Ищем элемент: 18

Проверяем позицию 4 (значение: 18) → СОВПАДАЕТ

Элемент найден на позиции: 4
# Определение
# Алгоритм поиска Фибоначчи (Fibonacci Search)
— это алгоритм, который находит позицию целевого элемента в отсортированном массиве с использованием чисел Фибоначчи для определения позиций сравнения.

### Объяснение работы алгоритма:
Алгоритм работает только с отсортированным массивом. Он сначала генерирует последовательность чисел Фибоначчи, достаточную для покрытия длины массива (while b < len(arr): fib_numbers.append(b)).

Алгоритм инициализирует смещение offset = -1 и индекс m, указывающий на последнее число Фибоначчи в последовательности.

На каждом шаге алгоритм вычисляет позицию для сравнения: idx = min(offset + fib_numbers[m-1], len(arr)-1).

Если элемент в вычисленной позиции меньше целевого (arr[idx] < target), алгоритм сдвигает окно поиска вправо (offset = idx) и уменьшает m на 1 (m -= 1).

Если элемент в вычисленной позиции больше целевого (arr[idx] > target), алгоритм сдвигает окно поиска, уменьшая m на 2 (m -= 2).

Если элемент найден (arr[idx] == target), алгоритм возвращает его индекс (return idx).

Процесс повторяется до нахождения элемента или исчерпания чисел Фибоначчи.

### Временная сложность
Временная сложность — O(log n).

Почему: алгоритм делит массив на части с помощью чисел Фибоначчи, что обеспечивает логарифмическое время поиска.

### Результат выполнения программы для массива [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100] и искомого значения 85:
Числа Фибоначчи: [1, 1, 2, 3, 5, 8]

Итерация 1: offset=-1, m=5, idx=4 (arr[4]=45) → 45 < 85 → offset=4, m=4

Итерация 2: offset=4, m=4, idx=7 (arr[7]=82) → 82 < 85 → offset=7, m=3

Итерация 3: offset=7, m=3, idx=8 (arr[8]=85) → СОВПАДАЕТ

Элемент 85 найден на позиции 8
