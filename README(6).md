# Вариант 9. Жадный алгоритм для задачи о максимальном разрезе
Задача: реализовать жадный алгоритм для задачи о максимальном разрезе (MAX CUT).
Требования:
- Разделить вершины графа на две группы для максимизации ребер между группами
- Вывести две группы вершин и количество ребер в разрезе
Входные данные:
Граф с 8 вершинами (полный граф или граф с 15 ребрами)



# Определение
### Жадный алгоритм для задачи о максимальном разрезе графа
— это алгоритм, который на каждом шаге находит вершину и размещает ее в ту группу, с которой у нее меньше связей, чтобы максимизировать количество ребер между группами.

### Объяснение работы алгоритма:
Алгоритм инициализирует две пустые группы (group_a = set() и group_b = set()).

Алгоритм создает список вершин для обработки (vertices = list(graph.keys())).

Алгоритм проходит по всем вершинам графа (for vertex in vertices:).

На каждом шаге он подсчитывает количество связей с группой A и группой B:  (connections_to_a и connections_to_b)

Алгоритм размещает вершину в группу с меньшим количеством связей: onnections_to_a <= connections_to_b:

Алгоритм возвращает полученные группы (return group_a, group_b)

### Временная сложность
Временная сложность — O(|V| + |E|).

Почему: наличие внешнего цикла (по всем вершинам |V| раз) и внутреннего цикла (по всем соседям каждой вершины, что в сумме дает |E| проверок) приводит к сложности O(|V| + |E|).


# Контрольные Вопросы №9
### Жадный алгоритм для покрытия множеств
Какой коэффициент аппроксимации имеет жадный алгоритм для задачи о покрытии множеств
и почему?

### Ответ
Жадный алгоритм для задачи о покрытии множеств имеет коэффициент аппроксимации H(n), где H(n) - n-ное гармоническое число, и H(n) ≤ ln n + 1.

Почему коэффициент аппроксимации H(n)

Доказательство через анализ "цены" элементов:

Распределение стоимости: Когда алгоритм выбирает множество S, мы "распределяем" его стоимость (1) равномерно среди новых элементов, которые он покрывает

Порядок покрытия: Элементы покрываются в определенном порядке. Рассмотрим элемент e, который покрывается на k-м шаге:

На момент покрытия e оставалось непокрытыми хотя бы n/k элементов

Оптимальное покрытие должно покрывать все эти элементы

Значит, оптимальное решение содержит множество, покрывающее хотя бы n/k из оставшихся элементов

Гармонические числа: Суммируя "цену" всех элементов:

Стоимость жадного алгоритма ≤ ∑(1/k) для k=1..n = H(n) ≤ ln n + 1

